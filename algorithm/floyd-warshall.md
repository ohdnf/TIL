# 플로이드-워샬(Floyd-Warshall) 알고리즘

모든 쌍 최단 경로를 찾는 동적 계획 알고리즘



## 모든 쌍 최단 경로 문제

- 모든 정점 사이에 가장 빨리 갈 수 있는 경로를 찾는 문제
- **가중치 포함, 방향성 그래프**
  - 음의 가중치 허용, 가중치 합이 음인 싸이클은 허용하지 않음
- 최적화 문제(Optimization problem)
  - 주어진 문제에 대하여 하나 이상의 많은 해답이 존재할 때, 이 가운데에서 가장 최적인 해답(OPtimal solution)을 찾아야 하는 문제



## 특징

- 각 정점을 시작점으로 정해서 **다익스트라(Dijkstra) 알고리즘 수행**
- **시간복잡도**는 리스트를 사용하면 **O(n^3)**이 됨
  - 모든 정점의 수 n * 다익스트라 알고리즘(O(n^2))
  - 다익스트라 알고리즘에서 리스트를 사용하면 O(n^2), 힙을 사용하면 O(elogn)
  - n은 정점의 수, e는 간선의 수
- 매우 간단하며, 음의 가중치를 허용하지 않는 다익스트라 알고리즘을 사용하는 것보다 효율적



### 플로이드-워샬 알고리즘 동작 과정

- 부분문제들을 찾아야 함
- 정점 i에서 정점 j로 가는 최단 경로는 직접 가는 경로와 다른 정점(k)들을 경유하는 경로 중 짧은 거리
- 경유 가능한 점들을 하나씩 추가해 나가면서 최단 경로 구하기(k = 1...n)

![formula](assets\floyd-warshall.png)

```python
# D[i][j]: i에서 j로 가는 최단 경로 가중치 합
# 최초 D[i][j]에는 간선(i, j)의 가중치 저장, i에서 j로 간선이 없으면 무수히 큰 수(INF) 저장

def AllPairsShortest(D):
    for k in range(1, n+1):
        for i in range(1, n+1):	# 단, i != k
           for j in range(1, n+1): # 단, j != k and j != i
               D[i][j] = min(D[i][k] + D[k][j], D[i][j])
```

- 새로운 `D[i][j]`를 계산하기 위해서 **미리 계산되어 있어야 할 부분 문제들**은 `D[i][k]`와 `D[k][j]`